// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace Ar.Com.Hjg.Pngcs {
	
	using Ar.Com.Hjg.Pngcs.Chunks;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
    using System;
     using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
	
	/// <summary>
	/// Reads a PNG image, line by line
	/// </summary>
	///
	public class PngReader {
		public readonly ImageInfo imgInfo;
		private readonly String filename; // optional
		private readonly Stream mask0;
		private readonly InflaterInputStream idatIstream;
		private readonly PngIDatChunkInputStream iIdatCstream;
		private int offset;
		// chunks: add exclusively with addChunkToList()
		private static int MAX_BYTES_CHUNKS_TO_LOAD = 640000;
		private int bytesChunksLoaded;
		private ChunkLoadBehaviour chunkLoadBehaviour;
		// private final int valsPerRow; // samples per row= cols x channels
		private int rowNum; // current row number
		private ImageLine imgLine;
		// line as bytes, counting from 1 (index 0 is reserved for filter type)
		private int[] rowb; // TODO: short would be nice
		private int[] rowbprev; // rowb previous
		private byte[] rowbfilter; // current line 'filtered'
		// chunks loaded: (IDAT is one dummy) These might be copied to the PngWriter
		public ChunkList chunks;
		// FoundChunkInfo/foundChunksInfo : all chunks signatures - merely informative
		private IList<FoundChunkInfo> foundChunksInfo;
	
		private class FoundChunkInfo {
			public readonly String id;
			public readonly int len;
			public readonly int offset;
			public readonly bool loaded;
	
			public FoundChunkInfo(String id_0, int len_1, int offset_2, bool loaded_3) {
				this.id = id_0;
				this.len = len_1;
				this.offset = offset_2;
				this.loaded = loaded_3;
			}
	
			public override String ToString() {
				return "chunk " + id + " len=" + len + " offset=" + offset
						+ ((this.loaded) ? " " : " X ");
			}
		}
	
		public PngReader(Stream inputStream) : this(inputStream, "[NO FILENAME AVAILABLE]") {
		}
	
		/// <summary>
		/// The constructor loads the header and first chunks, stopping at the
		/// beginning of the image data (IDAT chunks)
		/// </summary>
		///
		/// <param name="filename">Path of image file</param>
		public PngReader(Stream inputStream, String filenameOrDescription) {
			this.offset = 0;
			this.chunkLoadBehaviour = Ar.Com.Hjg.Pngcs.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_ALWAYS;
			this.rowNum = -1;
			this.rowb = null;
			this.rowbprev = null;
			this.rowbfilter = null;
			this.chunks = new ChunkList();
			this.foundChunksInfo = new List<FoundChunkInfo>();
			this.filename = (filenameOrDescription == null) ? "" : filenameOrDescription;
			this.mask0 = inputStream;
			// reads header (magic bytes)
			byte[] pngid = new byte[PngHelper.pngIdBytes.Length];
			Ar.Com.Hjg.Pngcs.PngHelper.ReadBytes(mask0, pngid, 0, pngid.Length);
			offset += pngid.Length;
			if (! PngCsUtils.arraysEqual4(pngid,Ar.Com.Hjg.Pngcs.PngHelper.pngIdBytes))
				throw new PngjInputException("Bad PNG signature");
			// reads first chunks
			int clen = Ar.Com.Hjg.Pngcs.PngHelper.ReadInt4(mask0);
			offset += 4;
			if (clen != 13)
				throw new Exception("IDHR chunk len != 13 ?? " + clen);
			byte[] chunkid = new byte[4];
			Ar.Com.Hjg.Pngcs.PngHelper.ReadBytes(mask0, chunkid, 0, 4);
            if (! PngCsUtils.arraysEqual4(chunkid,Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IHDR))
				throw new PngjInputException("IHDR not found as first chunk??? ["
						+ Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToString(chunkid) + "]");
			offset += 4;
			ChunkRaw chunk = new ChunkRaw(clen, chunkid, true);
			String chunkids = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToString(chunkid);
			foundChunksInfo.Add(new PngReader.FoundChunkInfo (chunkids, clen, offset - 8, true));
			offset += chunk.ReadChunkData(mask0);
			PngChunkIHDR ihdr = (PngChunkIHDR) AddChunkToList(chunk);
			if (ihdr.interlaced != 0)
				throw new PngjUnsupportedException("PNG interlaced not supported by this library");
			if (ihdr.filmeth != 0 || ihdr.compmeth != 0)
				throw new PngjInputException("compmethod o filtermethod unrecognized");
			bool alpha = (ihdr.colormodel & 0x04) != 0;
			bool palette = (ihdr.colormodel & 0x01) != 0;
			bool grayscale = (ihdr.colormodel == 0 || ihdr.colormodel == 4);
			if (ihdr.colormodel < 0 || ihdr.colormodel > 6 || ihdr.colormodel == 1
					|| ihdr.colormodel == 5)
				throw new PngjInputException("Invalid colormodel " + ihdr.colormodel);
			if (ihdr.bitspc != 1 && ihdr.bitspc != 2 && ihdr.bitspc != 4 && ihdr.bitspc != 8
					&& ihdr.bitspc != 16)
				throw new PngjInputException("Invalid bit depth " + ihdr.bitspc);
			imgInfo = new ImageInfo(ihdr.cols, ihdr.rows, ihdr.bitspc, alpha, grayscale, palette);
			imgLine = new ImageLine(imgInfo);
			// allocation
			rowb = new int[imgInfo.bytesPerRow + 1];
			rowbprev = new int[rowb.Length];
			rowbfilter = new byte[rowb.Length];
			int idatLen = ReadFirstChunks();
			if (idatLen < 0)
				throw new PngjInputException("first idat chunk not found!");
			iIdatCstream = new PngIDatChunkInputStream(mask0, idatLen, offset);
			idatIstream = new InflaterInputStream(iIdatCstream);
		}
	
		private PngChunk AddChunkToList(ChunkRaw chunk) {
			PngChunk chunkType = Ar.Com.Hjg.Pngcs.Chunks.PngChunk.Factory(chunk, imgInfo);
			// extra processing for some chunks
			// TODO:
			/*
			 * if (chunk.id.equals(PngChunkHelper.pHYs_TEXT)) { ByteArrayInputStream b =
			 * chunk.getAsByteStream(); int resx = PngHelper.readInt4(b); int resy =
			 * PngHelper.readInt4(b); int mode = PngHelper.readByte(b); // 1: meters if
			 * (mode == 1 & resx == resy) this.dpi = resx * 2.54 / 100.0; }
			 */
			// TODO: different chunk reading behaviour could allow to ignore some chunks
			if (!chunkType.crit) {
				bytesChunksLoaded += chunk.len;
			}
			if (bytesChunksLoaded > MAX_BYTES_CHUNKS_TO_LOAD) {
				throw new PngjInputException("Chunk exceeded available space ("
						+ MAX_BYTES_CHUNKS_TO_LOAD + ") chunk: " + chunk
						+ " See PngReader.MAX_BYTES_CHUNKS_TO_LOAD\n");
			}
			chunks.AppendChunk(chunkType);
			return chunkType;
		}
	
		/// <summary>
		/// Reads chunks before first IDAT. Position before: after IDHR (crc included)
		/// Position after: just after the first IDAT chunk id Returns length of first
		/// IDAT chunk , -1 if not found
		/// </summary>
		///
		private int ReadFirstChunks() {
			int clen = 0;
			bool found = false;
			byte[] chunkid = new byte[4]; // it's important to reallocate in each
																		// iteration
			while (!found) {
				clen = Ar.Com.Hjg.Pngcs.PngHelper.ReadInt4(mask0);
				offset += 4;
				if (clen < 0)
					break;
				Ar.Com.Hjg.Pngcs.PngHelper.ReadBytes(mask0, chunkid, 0, 4);
				offset += 4;
				if (PngCsUtils.arraysEqual4( chunkid,Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IDAT)) {
					found = true;
					// add dummy idat chunk to list
					ChunkRaw chunk = new ChunkRaw(0, chunkid, false);
					AddChunkToList(chunk);
					break;
                }
                else if (PngCsUtils.arraysEqual4(chunkid, Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IEND))
                {
					throw new PngjInputException(
							"END chunk found before image data (IDAT) at offset=" + offset);
				}
				ChunkRaw chunk_0 = new ChunkRaw(clen, chunkid, true);
				String chunkids = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToString(chunkid);
				bool loadchunk = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ShouldLoad(chunkids, chunkLoadBehaviour);
				foundChunksInfo.Add(new PngReader.FoundChunkInfo (chunkids, clen, offset - 8, loadchunk));
				offset += chunk_0.ReadChunkData(mask0);
				if (loadchunk)
					AddChunkToList(chunk_0);
			}
			return (found) ? clen : -1;
		}
	
		/// <summary>
		/// Reads (and processes ... up to a point) chunks after last IDAT.
		/// </summary>
		///
		private void ReadLastChunks() {
			// PngHelper.logdebug("idat ended? " + iIdatCstream.isEnded());
			if (!iIdatCstream.IsEnded())
				iIdatCstream.ForceChunkEnd();
			/* foreach */
			// add chunks to list (just informational)
			foreach (Ar.Com.Hjg.Pngcs.PngIDatChunkInputStream.IdatChunkInfo  idat  in  iIdatCstream.foundChunksInfo)
				foundChunksInfo.Add(new PngReader.FoundChunkInfo (Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IDAT_TEXT, idat.len,
									idat.offset, true));
			int clen = iIdatCstream.GetLenLastChunk();
			byte[] chunkid = iIdatCstream.GetIdLastChunk();
			bool endfound = false;
			bool first = true;
			bool ignore = false;
			while (!endfound) {
				ignore = false;
				if (!first) {
					clen = Ar.Com.Hjg.Pngcs.PngHelper.ReadInt4(mask0);
					offset += 4;
					if (clen < 0)
						throw new PngjInputException("bad len " + clen);
					Ar.Com.Hjg.Pngcs.PngHelper.ReadBytes(mask0, chunkid, 0, 4);
					offset += 4;
				}
				first = false;
				if (PngCsUtils.arraysEqual4(chunkid,Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IDAT)) {
					// PngHelper.logdebug("extra IDAT chunk len - ignoring : ");
					ignore = true;
                }
                else if (PngCsUtils.arraysEqual4(chunkid, Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IEND))
                {
					endfound = true;
				}
				ChunkRaw chunk = new ChunkRaw(clen, chunkid, true);
				String chunkids = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToString(chunkid);
				bool loadchunk = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ShouldLoad(chunkids, chunkLoadBehaviour);
				foundChunksInfo.Add(new PngReader.FoundChunkInfo (chunkids, clen, offset - 8, loadchunk));
				offset += chunk.ReadChunkData(mask0);
				if (loadchunk && !ignore) {
					AddChunkToList(chunk);
				}
			}
			if (!endfound)
				throw new PngjInputException("end chunk not found - offset=" + offset);
			// PngHelper.logdebug("end chunk found ok offset=" + offset);
		}
	
		/// <summary>
		/// calls readRow(int[] buffer, int nrow), usin LineImage as buffer
		/// </summary>
		///
		/// <returns>the ImageLine that also is available inside this object</returns>
		public ImageLine ReadRow(int nrow) {
			ReadRow(imgLine.scanline, nrow);
			imgLine.IncRown();
			return imgLine;
		}
	
		/// <summary>
		/// Reads a line and returns it as a int array Buffer can be prealocated (in
		/// this case it must have enough len!) or can be null See also the other
		/// overloaded method
		/// </summary>
		///
		/// <param name="buffer"></param>
		/// <param name="nrow"></param>
		/// <returns>The same buffer if it was allocated, a newly allocated one
		/// otherwise</returns>
		public int[] ReadRow(int[] buffer, int nrow) {
			if (nrow < 0 || nrow >= imgInfo.rows)
				throw new PngjInputException("invalid line");
			if (nrow != rowNum + 1)
				throw new PngjInputException("invalid line (expected: " + (rowNum + 1));
			rowNum++;
			if (buffer == null)
				buffer = new int[imgInfo.samplesPerRowP];
			// swap
			int[] tmp = rowb;
			rowb = rowbprev;
			rowbprev = tmp;
			// loads in rowbfilter "raw" bytes, with filter
			Ar.Com.Hjg.Pngcs.PngHelper.ReadBytes(idatIstream, rowbfilter, 0, rowbfilter.Length);
			rowb[0] = rowbfilter[0];
			UnfilterRow();
			ConvertRowFromBytes(buffer);
			return buffer;
		}
	
		private void ConvertRowFromBytes(int[] buffer) {
			// http://www.libpng.org/pub/png/spec/1.2/PNG-DataRep.html
			int i, j;
			if (imgInfo.bitDepth <= 8) {
				for (i = 0, j = 1; i < imgInfo.samplesPerRowP; i++) {
					buffer[i] = (rowb[j++]);
				}
			} else { // 16 bitspc
				for (i = 0, j = 1; i < imgInfo.samplesPerRowP; i++) {
					buffer[i] = (rowb[j++] << 8) + rowb[j++];
				}
			}
		}
	
		private void UnfilterRow() {
			int ftn = rowbfilter[0];
            PngFilterType ft = (PngFilterType)ftn;
			/*if (ft == null)
				throw new PngjInputException("Filter type " + ftn + " invalid");*/
			switch (ft) {
			case Ar.Com.Hjg.Pngcs.PngFilterType.FILTER_NONE:
				UnfilterRowNone();
				break;
			case Ar.Com.Hjg.Pngcs.PngFilterType.FILTER_SUB:
				UnfilterRowSub();
				break;
			case Ar.Com.Hjg.Pngcs.PngFilterType.FILTER_UP:
				UnfilterRowUp();
				break;
			case Ar.Com.Hjg.Pngcs.PngFilterType.FILTER_AVERAGE:
				UnfilterRowAverage();
				break;
			case Ar.Com.Hjg.Pngcs.PngFilterType.FILTER_PAETH:
				UnfilterRowPaeth();
				break;
			default:
				throw new PngjInputException("Filter type " + ftn + " not implemented");
			}
		}
	
		private void UnfilterRowNone() {
			for (int i = 1; i <= imgInfo.bytesPerRow; i++) {
				rowb[i] = (int) (rowbfilter[i] & 0xFF);
			}
		}
	
		private void UnfilterRowSub() {
			int i, j;
			for (i = 1; i <= imgInfo.bytesPixel; i++) {
				rowb[i] = (int) (rowbfilter[i] & 0xFF);
			}
			for (j = 1, i = imgInfo.bytesPixel + 1; i <= imgInfo.bytesPerRow; i++, j++) {
				rowb[i] = ((int) (rowbfilter[i] & 0xFF) + rowb[j]) & 0xFF;
			}
		}
	
		private void UnfilterRowUp() {
			for (int i = 1; i <= imgInfo.bytesPerRow; i++) {
				rowb[i] = ((int) (rowbfilter[i] & 0xFF) + rowbprev[i]) & 0xFF;
			}
		}
	
		private void UnfilterRowAverage() {
			int i, j, x;
			for (j = 1 - imgInfo.bytesPixel, i = 1; i <= imgInfo.bytesPerRow; i++, j++) {
				x = (j > 0) ? rowb[j] : 0;
				rowb[i] = ((int) (rowbfilter[i] & 0xFF) + (x + rowbprev[i]) / 2) & 0xFF;
			}
		}
	
		private void UnfilterRowPaeth() {
			int i, j, x, y;
			for (j = 1 - imgInfo.bytesPixel, i = 1; i <= imgInfo.bytesPerRow; i++, j++) {
				x = (j > 0) ? rowb[j] : 0;
				y = (j > 0) ? rowbprev[j] : 0;
				rowb[i] = ((int) (rowbfilter[i] & 0xFF) + Ar.Com.Hjg.Pngcs.PngHelper.FilterPaethPredictor(x,
						rowbprev[i], y)) & 0xFF;
			}
		}
	
		/// <summary>
		/// This should be called after having read the last line. It reads extra
		/// chunks after IDAT
		/// </summary>
		///
		public void End() {
			offset = (int) iIdatCstream.GetOffset();
			try {
				idatIstream.Close();
			} catch (Exception ) {
			}
			ReadLastChunks();
			try {
				mask0.Close();
			} catch (Exception e_0) {
				throw new PngjInputException("error closing input stream!", e_0);
			}
		}
	
		public override String ToString() { // basic info
			return "filename=" + filename + " " + imgInfo.ToString();
		}
	
		public void PrintFoundChunks() {
			/* foreach */
			foreach (PngReader.FoundChunkInfo  c  in  foundChunksInfo) {
				System.Console.Out.WriteLine(c);
			}
		}
	
		/// <summary>
		/// for debug 
		/// </summary>
		///
		public static void ShowLineInfo(ImageLine line) {
			System.Console.Out.WriteLine(line);
			Ar.Com.Hjg.Pngcs.ImageLineHelper.ImageLineStats  stats = new ImageLineHelper.ImageLineStats(line);
			System.Console.Out.WriteLine(stats);
			System.Console.Out.WriteLine(Ar.Com.Hjg.Pngcs.ImageLineHelper.InfoFirstLastPixels(line));
		}
	}
}
