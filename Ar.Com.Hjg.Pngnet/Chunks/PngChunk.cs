// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace Ar.Com.Hjg.Pngcs.Chunks
{

    using Ar.Com.Hjg.Pngcs;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;

    // see http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
    public abstract class PngChunk
    {
        public readonly String id; // 4 letters
        public readonly bool crit, pub, safe, known, beforeIDAT, beforePLTE;
        private int lenori; // merely informational, for read chunks
        // 0:queued ; 1: queued prioritary; 2: dont write yet; 3: already written
        private int writeStatus;
        protected internal readonly ImageInfo imgInfo;

        protected internal PngChunk(String id_0, ImageInfo imgInfo_1)
        {
            this.lenori = -1;
            this.writeStatus = 0;
            this.id = id_0;
            this.imgInfo = imgInfo_1;
            this.crit = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsCritical(id_0);
            this.pub = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsPublic(id_0);
            this.safe = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsSafeToCopy(id_0);
            this.known = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsKnown(id_0);
            // beforeIDAT=true: MUST go before IDATA
            this.beforeIDAT = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.BeforeIDAT(id_0);
            // beforePLTE=true: MUST go before PLTE (if present)
            this.beforePLTE = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.BeforePLTE(id_0);
        }

        public abstract ChunkRaw CreateChunk();

        public abstract void ParseFromChunk(ChunkRaw c);

        // override to make deep copy from read data to write
        public abstract void CloneDataFromRead(PngChunk other);

        /* @SuppressWarnings("unchecked")*/
        public static T CloneChunk<T>(T chunk, ImageInfo info) where T : PngChunk
        {
            PngChunk cn = FactoryFromId(chunk.id, info);
            if ((Object)cn.GetType() != (Object)chunk.GetType())
                throw new PngjException("bad class cloning chunk: " + cn.GetType() + " "
                        + chunk.GetType());
            cn.CloneDataFromRead(chunk);
            return (T)cn;
        }

        public static PngChunk Factory(ChunkRaw chunk, ImageInfo info)
        {
            PngChunk c = FactoryFromId(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToString(chunk.idbytes), info);
            c.lenori = chunk.len;
            c.ParseFromChunk(chunk);
            return c;
        }

        public static PngChunk FactoryFromId(String cid, ImageInfo info)
        {
            PngChunk ctype = null;
            if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IDAT_TEXT))
                ctype = new PngChunkIDAT(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IHDR_TEXT))
                ctype = new PngChunkIHDR(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.PLTE_TEXT))
                ctype = new PngChunkPLTE(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IEND_TEXT))
                ctype = new PngChunkIEND(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.gAMA_TEXT))
                ctype = new PngChunkGAMA(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.tEXt_TEXT))
                ctype = new PngChunkTEXT(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.iTXt_TEXT))
                ctype = new PngChunkOTHER(cid, info);// new ChunkTypeITXT(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.zTXt_TEXT))
                ctype = new PngChunkOTHER(cid, info);// new ChunkTypeZTXT(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.pHYs_TEXT))
                ctype = new PngChunkPHYS(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.bKGD_TEXT))
                ctype = new PngChunkBKGD(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.iCCP_TEXT))
                ctype = new PngChunkICCP(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.tIME_TEXT))
                ctype = new PngChunkTIME(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.tRNS_TEXT))
                ctype = new PngChunkTRNS(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.cHRM_TEXT))
                ctype = new PngChunkCHRM(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.sBIT_TEXT))
                ctype = new PngChunkSBIT(info);
            else if (cid.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.sRGB_TEXT))
                ctype = new PngChunkSRGB(info);
            else
                ctype = new PngChunkOTHER(cid, info);
            return ctype;
        }

        protected internal ChunkRaw CreateEmptyChunk(int len, bool alloc)
        {
            ChunkRaw c = new ChunkRaw(len, Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToBytes(id), alloc);
            return c;
        }

        public override String ToString()
        {
            return "chunk id= " + id + " (" + lenori + ") c=" + GetType().Name;
        }

        /// <summary>
        /// should be called for ancillary chunks only Our write order is defined as
        /// (0:IDHR) 1: after IDHR (2:PLTE if present) 3: before IDAT (4:IDAT) 5: after
        /// IDAT (6:END)
        /// </summary>
        ///
        public int WriteOrder()
        {
            if (id.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IHDR))
                return 0;
            if (id.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.PLTE))
                return 2;
            if (id.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IDAT))
                return 4;
            if (id.Equals(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IEND))
                return 6;
            if (Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.BeforePLTE(id))
                return 1;
            if (Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.BeforeIDAT(id))
                return 3;
            else
                return 5;
        }

        public int GetWriteStatus()
        {
            return writeStatus;
        }

        public void SetWriteStatus(int writeStatus_0)
        {
            this.writeStatus = writeStatus_0;
        }

        public void WriteAndMarkAsWrite(Stream os)
        {
            if (GetWriteStatus() >= 2)
                throw new Exception("bad write status");
            ChunkRaw c = CreateChunk();
            if (c != null)
                c.WriteChunk(os);
            else
                System.Console.Error.WriteLine("null chunk ! for " + this);
            SetWriteStatus(3);
        }
    }
}
