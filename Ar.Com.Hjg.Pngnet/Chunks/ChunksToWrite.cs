// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace Ar.Com.Hjg.Pngcs.Chunks {
	
	using Ar.Com.Hjg.Pngcs;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Chunks to be written - not including IDHR/ IDAT / END (buy yes PLTE)
	/// http://www.w3.org/TR/PNG/#table53
	/// </summary>
	///
	public class ChunksToWrite {
		public sealed class Anonymous_C0 : IComparer<PngChunk> {
			public int Compare(PngChunk o1, PngChunk o2) {
				if (o1.GetWriteStatus() != o2.GetWriteStatus())
					return (o1.GetWriteStatus() < o2.GetWriteStatus()) ? 1 : -1;
				else
					return CompareInt(o1.WriteOrder(), o2.WriteOrder());
			}
		}
	
		public const int COPY_NONE = 0;
		public const int COPY_PALETTE = 1; // only for indexed - use COPY_ALL
																							// for copy palette for RGB
		public const int COPY_ALL_SAFE = 1 << 2;
		public const int COPY_ALL = 1 << 3; // includes palette!
		public const int COPY_PHYS = 1 << 4; // dpi
		public const int COPY_TEXTUAL = 1 << 5; // all textual types
		public const int COPY_TRANSPARENCY = 1 << 6; //
	
		public static bool MaskMatch(int v, int mask) {
			return (v & mask) != 0;
		}
	
		public readonly ImageInfo imgInfo;
		// ancillary chunks single
		private IDictionary<String, PngChunk> chunks1;
		// other chunks (possibly multiple): text, splt, custom
		private IList<PngChunk> chunks2;
		private PngChunkPLTE palette;
	
		public ChunksToWrite(ImageInfo info) {
			this.chunks1 = new Dictionary<String, PngChunk>();
			this.chunks2 = new List<PngChunk>();
			this.palette = null;
			this.imgInfo = info;
		}
	
		public IList<PngChunk> GetPending() { // can include palette
			IList<PngChunk> li = new List<PngChunk>();
			/* foreach */
			foreach (PngChunk c  in  chunks1.Values)
				if (c.GetWriteStatus() <= 1)
					li.Add(c);
			if (palette != null && palette.GetWriteStatus() <= 1)
				li.Add(palette);
			/* foreach */
			foreach (PngChunk c_0  in  chunks2)
				if (c_0.GetWriteStatus() <= 1)
					li.Add(c_0);
			//li.S,new ChunksToWrite.Anonymous_C0 ());
            // TODO: sort
			return li;
		}
	
		private static int CompareInt(int a, int b) {
			return (a < b) ? -1 : 1;
		}
	
		public void SetPHYS(long resx, long resy, int unit) {
			if (!chunks1.ContainsKey(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.pHYs_TEXT))
				chunks1.Add(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.pHYs_TEXT,new PngChunkPHYS(imgInfo));
			PngChunkPHYS chunk = (PngChunkPHYS) chunks1[Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.pHYs_TEXT];
			chunk.pixelsxUnitX = resx;
			chunk.pixelsxUnitY = resy;
			chunk.units = unit;
		}
	
		public void SetPHYSdpi(double dpi) {
			long res = Ar.Com.Hjg.Pngcs.PngHelper.ResDpiToMeters(dpi);
			SetPHYS(res, res, 1);
		}
	
		public void CopyPalette(PngChunkPLTE p) {
			palette = Ar.Com.Hjg.Pngcs.Chunks.PngChunk.CloneChunk(p, imgInfo);
		}
	
		public void CloneAndAdd(PngChunk p, bool overwrite) {
			if (p  is  PngChunkPLTE) {
				if (palette != null && !overwrite)
					return;
				CopyPalette((PngChunkPLTE) p);
			} else if (Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.AdmitsMultiple(p.id)) {
				chunks2.Add(Ar.Com.Hjg.Pngcs.Chunks.PngChunk.CloneChunk(p, imgInfo));
			} else { // singletons: checks for existence
				if (chunks1.ContainsKey(p.id) && !overwrite)
					return;
				else
					chunks1.Add(p.id,Ar.Com.Hjg.Pngcs.Chunks.PngChunk.CloneChunk(p, imgInfo));
			}
		}
	}
}
