// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace Ar.Com.Hjg.Pngcs.Chunks {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// All chunks that form an image, read or to be written
	/// http://www.w3.org/TR/PNG/#table53
	/// </summary>
	///
	public class ChunkList {
		// chunks include all chunks, but IDAT is a single pseudo chunk without data
		private IList<PngChunk> chunks;
		// for each chunkid, says the position(s) in list
		private IDictionary<String, IList<Int32>> positions;
		private bool positionsDirty; // positions need recalc
	
		public ChunkList() {
			this.chunks = new List<PngChunk>();
			this.positions = new Dictionary<String, IList<Int32>>();
			this.positionsDirty = true;
		}
	
		public void Check() {
			// checks that the order is right
			// TODO: check
		}
	
		private void RecalcPositions() {
			positions.Clear();
			for (int i = 0; i < chunks.Count; i++) {
				String chunkid = chunks[i].id;
                if (!positions.ContainsKey(chunkid))
                {
                    positions.Add(chunkid, new List<Int32>());
                }
				positions[chunkid].Add(i);
			}
			positionsDirty = false;
		}
	
		public void AppendChunk(PngChunk chunk) {
			// adds in next position. this should be used when reading
			chunks.Add(chunk);
			positionsDirty = true;
		}
	
		public void InsertChunk(PngChunk chunk, int afterPos) {
			chunks.Insert(afterPos + 1, chunk);
			positionsDirty = true;
		}
	
		public void InsertChunk(PngChunk chunk) {
			// will be inserted according to type
			// TODO
			positionsDirty = true;
		}
	
		public void RemoveChunk(PngChunk chunk) {
			chunks.Remove(chunk);
			positionsDirty = true;
		}
	
		public void RemoveChunk(int pos) {
            chunks.RemoveAt(pos);
			positionsDirty = true;
		}
	
		public IList<PngChunk> GetChunks() {
			if (positionsDirty)
				RecalcPositions();
			return chunks;
		}
	
		public PngChunk GetChunk(int i) {
			if (i < 0)
				return null;
			else
				return chunks[i];
		}
	
		public int NOcurrences(String chunkId) {
			if (positionsDirty)
				RecalcPositions();
			return (positions.ContainsKey(chunkId)) ? positions[chunkId].Count : 0;
		}
	
		public int FirstOcurrence(String chunkId) {
			if (positionsDirty)
				RecalcPositions();
			return (positions.ContainsKey(chunkId)) ? (int)positions[chunkId][0] : (int) (-1);
		}
	
		/* @SuppressWarnings("unchecked")*/
		public IList<Int32> AllOcurrences(String chunkId) {
			if (positionsDirty)
				RecalcPositions();
            return (positions.ContainsKey(chunkId)) ?positions[chunkId]
                    : (IList<Int32>)new List<Int32>();
		}
	
		public int PositionIDAT() {
			return FirstOcurrence(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IDAT_TEXT);
		}
	
		public int PositionIEND() {
			return FirstOcurrence(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IEND_TEXT);
		}
	
		public override String ToString() {
			StringBuilder sb = new StringBuilder();
			/* foreach */
			foreach (PngChunk chunk  in  chunks) {
				sb.Append(chunk).Append("\n");
			}
			return sb.ToString();
		}
	}
}
