// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace Ar.Com.Hjg.Pngcs
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;


    /// <summary>
    /// Lightweight wrapper for an image scanline, for read and write
    /// It can be (usually it is) reused while iterating over the image lines
    /// IMPORTANT - READ THIS
    /// The 'scanline' is an array of integers, corresponds to an image line (row)
    /// Except for 'packed' formats (gray/indexed with 1-2-4 bitdepth) each int is a
    /// "sample" (one for channel), (0-255 or 0-65535) in the respective PNG sequence
    /// sequence : (R G B R G B...) or (R G B A R G B A...) or (g g g ...) or ( i i i
    /// ) (palette index)
    /// For bitdepth 1/2/4 , each element is a PACKED byte! To get an unpacked copy,
    /// see tf_pack() and its inverse tf_unpack()
    /// To convert a indexed line to RGB balues, see ImageLineHelper.tf_palIdx2RGB()
    /// (cant do the reverse)
    /// </summary>
    ///
    public class ImageLine
    {
        public readonly ImageInfo ImgInfo;
        internal readonly int channels; // copied from imgInfo, more handy
        internal readonly int bitDepth; // copied from imgInfo, more handy
        public readonly int[] Scanline; // see explanation above!!
        /// <summary>
        /// tracks the current row number (from 0 to rows-1)
        /// </summary>
        ///
        private int rown;

        public ImageLine(ImageInfo imgInfo_0)
        {
            this.rown = 0;
            this.ImgInfo = imgInfo_0;
            channels = imgInfo_0.Channels;
            Scanline = new int[imgInfo_0.SamplesPerRowP];
            this.bitDepth = imgInfo_0.BitDepth;
        }


        public int GetRown()
        {
            return rown;
        }

        public void IncRown()
        {
            this.rown++;
        }

        public void SetRown(int n)
        {
            this.rown = n;
        }

        public void SetScanLine(int[] b)
        { // makes copy
            System.Array.Copy((Array)(b), 0, (Array)(Scanline), 0, Scanline.Length);
        }

        public int[] GetScanLineCopy(int[] b)
        { // makes copy - normally not necessary
            if (b == null || b.Length < Scanline.Length)
                b = new int[Scanline.Length];
            System.Array.Copy((Array)(Scanline), 0, (Array)(b), 0, Scanline.Length);
            return b;
        }

        /// <summary>
        /// Unpacks scanline (for bitdepth 1-2-4) into buffer. It returns the same buf
        /// -except if it's null, in that case it allocates it.
        /// If scale==TRUE shifts the value
        /// </summary>
        ///
        public int[] Tf_unpack(int[] buf, bool scale)
        {
            int len = Scanline.Length;
            if (bitDepth == 1)
                len *= 8;
            else if (bitDepth == 2)
                len *= 4;
            else if (bitDepth == 4)
                len *= 2;
            if (buf == null)
                buf = new int[len];
            if (bitDepth >= 8)
                System.Array.Copy((Array)(Scanline), 0, (Array)(buf), 0, Scanline.Length);
            else
            {
                int mask, offset, v;
                int mask0 = GetMaskForPackedFormats();
                int offset0 = 8 - bitDepth;
                mask = mask0;
                offset = offset0;
                for (int i = 0, j = 0; i < len; i++)
                {
                    v = (Scanline[j] & mask) >> offset;
                    if (scale)
                        v <<= offset0;
                    buf[i] = v;
                    mask = mask >> bitDepth;
                    offset -= bitDepth;
                    if (mask == 0)
                    { // new byte in source
                        mask = mask0;
                        offset = offset0;
                        j++;
                    }
                }
            }
            return buf;
        }

        /// <summary>
        /// Packs scanline (for bitdepth 1-2-4) from buffer.
        /// If scale==TRUE shifts the value
        /// </summary>
        ///
        public void Tf_pack(int[] buf, bool scale)
        { // writes scanline
            int len = Scanline.Length;
            if (bitDepth == 1)
                len *= 8;
            else if (bitDepth == 2)
                len *= 4;
            else if (bitDepth == 4)
                len *= 2;
            if (bitDepth >= 8)
                System.Array.Copy((Array)(buf), 0, (Array)(Scanline), 0, Scanline.Length);
            else
            {
                int offset0 = 8 - bitDepth;
                int mask0 = GetMaskForPackedFormats() >> offset0;
                int offset, v;
                offset = offset0;
                Array.Clear(Scanline, 0, Scanline.Length);
                for (int i = 0, j = 0; i < len; i++)
                {
                    v = buf[i];
                    if (scale)
                        v >>= offset0;
                    v = (v & mask0) << offset;
                    Scanline[j] |= v;
                    offset -= bitDepth;
                    if (offset < 0)
                    { // new byte in scanline
                        offset = offset0;
                        j++;
                    }
                }
            }
        }

        private int GetMaskForPackedFormats()
        { // Utility function for pacj/unpack
            if (bitDepth == 1)
                return 0x80;
            if (bitDepth == 2)
                return 0xc0;
            if (bitDepth == 4)
                return 0xf0;
            throw new Exception("?");
        }

        public override String ToString()
        {
            return "row=" + rown + " cols=" + ImgInfo.Cols + " bpc=" + ImgInfo.BitDepth
                    + " size=" + Scanline.Length;
        }

        public static void showLineInfo(ImageLine line)
        {
            Console.WriteLine(line.ToString());
            ImageLineHelper.ImageLineStats stats = new ImageLineHelper.ImageLineStats(line);
            Console.WriteLine(stats.ToString());
            Console.WriteLine(ImageLineHelper.InfoFirstLastPixels(line));
        }
    }
}
