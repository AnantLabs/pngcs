// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace Ar.Com.Hjg.Pngcs {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Simple IMMUTABLE wrapper for basic image info
	/// Some parameters are clearly redundant
	/// The constructor requires an 'ortogonal' subset
	/// http://www.w3.org/TR/PNG/#11IHDR
	/// </summary>
	///
	public class ImageInfo {
		/// <summary>
		/// image width, in pixels
		/// </summary>
		///
		public readonly int cols;
		/// <summary>
		/// image height, in pixels
		/// </summary>
		///
		public readonly int rows;
		/// <summary>
		/// Bits per sample (per channel) in the buffer. This is 8 or 16 for RGB/ARGB
		/// images, For grayscale, it's 8 (or 1 2 4 ) For indexed images, number of
		/// bits per palette index (1 2 4 8)
		/// </summary>
		///
		public readonly int bitDepth;
		/// <summary>
		/// Number of channels, used in the buffer (warning!) This is 3-4 for rgb/rgba,
		/// but 1 for palette/gray !
		/// </summary>
		///
		public readonly int channels;
		/// <summary>
		/// Bits used for each pixel in the buffer equals channel/// bitDepth
		/// </summary>
		///
		public readonly int bitspPixel;
		public readonly int bytesPixel; // rounded up : this is only for filter!
		/// <summary>
		/// ceil(bitspp///cols/8)
		/// </summary>
		///
		public readonly int bytesPerRow;
		/// <summary>
		/// Equals cols x channels
		/// </summary>
		///
		public readonly int samplesPerRow;
		/// <summary>
		/// Samples available for our packed scanline Equals samplesPerRow if not
		/// packed Elsewhere, it's lower
		/// </summary>
		///
		public readonly int samplesPerRowP;
		public readonly bool alpha;
		public readonly bool greyscale;
		public readonly bool indexed;
		// less than one byte per sample (bit depth 1-2-4)
		public readonly bool packed;
		private const int MAX_COLS_ROWS_VAL = 400000; // very big value
	
		/// <summary>
		/// Constructor default: only for RGB (truecolor)!
		/// </summary>
		///
		public ImageInfo(int cols_0, int rows_1, int bitdepth, bool alpha_2) : this(cols_0, rows_1, bitdepth, alpha_2, false, false) {
		}
	
		/// <summary>
		/// Constructor
		/// </summary>
		///
		/// <param name="cols_0">width in pixels</param>
		/// <param name="rows_1">height in pixels</param>
		/// <param name="bitdepth"></param>
		/// <param name="alpha_2"></param>
		/// <param name="grayscale"></param>
		/// <param name="palette"></param>
		public ImageInfo(int cols_0, int rows_1, int bitdepth, bool alpha_2, bool grayscale,
				bool palette) {
			this.cols = cols_0;
			this.rows = rows_1;
			this.alpha = alpha_2;
			this.indexed = palette;
			this.greyscale = grayscale;
			if (greyscale && palette)
				throw new PngjException("palette and greyscale are exclusive");
			this.channels = (grayscale || palette) ? ((alpha_2) ? 2 : 1) : ((alpha_2) ? 4 : 3);
			// http://www.w3.org/TR/PNG/#11IHDR
			this.bitDepth = bitdepth;
			this.packed = bitdepth < 8;
			this.bitspPixel = (channels * this.bitDepth);
			this.bytesPixel = (bitspPixel + 7) / 8;
			this.bytesPerRow = (bitspPixel * cols_0 + 7) / 8;
			this.samplesPerRow = channels * this.cols;
			this.samplesPerRowP = (packed) ? bytesPerRow : samplesPerRow;
			// checks
			switch (this.bitDepth) {
			case 1:
			case 2:
			case 4:
				if (!(this.indexed || this.greyscale))
					throw new PngjException("only indexed or grayscale can have bitdepth="
							+ this.bitDepth);
				break;
			case 8:
				break;
			case 16:
				if (this.indexed)
					throw new PngjException("indexed can't have bitdepth=" + this.bitDepth);
				break;
			default:
				throw new PngjException("invalid bitdepth=" + this.bitDepth);
			}
			if (cols_0 < 1 || cols_0 > MAX_COLS_ROWS_VAL)
				throw new PngjException("invalid cols=" + cols_0 + " ???");
			if (rows_1 < 1 || rows_1 > MAX_COLS_ROWS_VAL)
				throw new PngjException("invalid rows=" + rows_1 + " ???");
		}
	
		public override String ToString() {
			return "ImageInfo [cols=" + cols + ", rows=" + rows + ", bitDepth=" + bitDepth
					+ ", channels=" + channels + ", bitspPixel=" + bitspPixel + ", bytesPixel="
					+ bytesPixel + ", bytesPerRow=" + bytesPerRow + ", samplesPerRow="
					+ samplesPerRow + ", samplesPerRowP=" + samplesPerRowP + ", alpha=" + alpha
					+ ", greyscale=" + greyscale + ", indexed=" + indexed + ", packed=" + packed
					+ "]";
		}
	
		public override int GetHashCode() {
			int prime = 31;
			int result = 1;
			result = prime * result + ((alpha) ? 1231 : 1237);
			result = prime * result + bitDepth;
			result = prime * result + bitspPixel;
			result = prime * result + bytesPerRow;
			result = prime * result + bytesPixel;
			result = prime * result + channels;
			result = prime * result + cols;
			result = prime * result + ((greyscale) ? 1231 : 1237);
			result = prime * result + ((indexed) ? 1231 : 1237);
			result = prime * result + ((packed) ? 1231 : 1237);
			result = prime * result + rows;
			result = prime * result + samplesPerRow;
			return result;
		}
	
		public override bool Equals(Object obj) {
			if ((Object) this == obj)
				return true;
			if (obj == null)
				return false;
			if ((Object) GetType() != (Object) obj.GetType())
				return false;
			ImageInfo other = (ImageInfo) obj;
			if (alpha != other.alpha)
				return false;
			if (bitDepth != other.bitDepth)
				return false;
			if (bitspPixel != other.bitspPixel)
				return false;
			if (bytesPerRow != other.bytesPerRow)
				return false;
			if (bytesPixel != other.bytesPixel)
				return false;
			if (channels != other.channels)
				return false;
			if (cols != other.cols)
				return false;
			if (greyscale != other.greyscale)
				return false;
			if (indexed != other.indexed)
				return false;
			if (packed != other.packed)
				return false;
			if (rows != other.rows)
				return false;
			if (samplesPerRow != other.samplesPerRow)
				return false;
			return true;
		}
	}
}
