// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace Ar.Com.Hjg.Pngcs.Chunks
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;

    /// <summary>
    /// All chunks that form an image, read or to be written
    /// http://www.w3.org/TR/PNG/#table53
    /// </summary>
    ///
    public class ChunksList
    {
        internal const int CHUNK_GROUP_0_IDHR = 0; // required - single
        internal const int CHUNK_GROUP_1_AFTERIDHR = 1; // optional - multiple
        internal const int CHUNK_GROUP_2_PLTE = 2; // optional - single
        internal const int CHUNK_GROUP_3_AFTERPLTE = 3; // optional - multple
        internal const int CHUNK_GROUP_4_IDAT = 4; // required (single pseudo chunk)
        internal const int CHUNK_GROUP_5_AFTERIDAT = 5; // optional - multple
        internal const int CHUNK_GROUP_6_END = 6; // only 1 chunk - requried


        // chunks include all chunks, but IDAT is a single pseudo chunk without data
        protected List<PngChunk> chunks;

        internal readonly ImageInfo imageInfo; // only required for writing

        public ChunksList(ImageInfo imfinfo)
        {
            this.chunks = new List<PngChunk>();
            this.imageInfo = imfinfo;
        }

        /**
     * processed (read or writen) chunks
     */
        public HashSet<String> GetChunksKeys()
        {
            HashSet<String> ck = new HashSet<String>();
            foreach (PngChunk c in chunks)
                ck.Add(c.Id);
            return ck;
        }

        /**
   * returns a copy of the list (but the chunks are not copied) <b> This should not be used for general metadata
   * handling
   */
        public List<PngChunk> GetChunks()
        {
            return new List<PngChunk>(chunks);
        }


        protected static List<PngChunk> GetXById(List<PngChunk> list, String id, String innerid)
        {
            if (innerid == null)
                return ChunkHelper.FilterList(list, new ChunkPredicateId(id));
            else
                return ChunkHelper.FilterList(list, new ChunkPredicateId2(id, innerid));
        }

        /**
        * Adds chunk in next position. This is used onyl by the pngReader
        */
        public void AppendReadChunk(PngChunk chunk, int chunkGroup)
        {
            chunk.ChunkGroup =chunkGroup;
            chunks.Add(chunk);
        }

        public List<PngChunk> GetById(String id)
        {
            return GetById(id, null);
        }

        /**
         * If innerid!=null and the chunk is PngChunkTextVar or PngChunkSPLT, it's filtered by that id
         */
        public List<PngChunk> GetById(String id, String innerid)
        {
            return GetXById(chunks, id, innerid);
        }

        /**
         * returns only one chunk or null if nothing found - does not include queued
         * <p>
         * If more than one chunk (after filtering by inner id) is found, then an exception is thrown (failifMultiple=true
         * or chunk is single) or the last one is returned (failifMultiple=false)
         **/
        public PngChunk GetById1(String id, String innerid, bool failIfMultiple)
        {
            List<PngChunk> list = GetById(id, innerid);
            if (list.Count == 0)
                return null;
            if (list.Count > 1 && (failIfMultiple || !list[0].AllowsMultiple()))
                throw new PngjException("unexpected multiple chunks id=" + id);
            return list[list.Count - 1];
        }

        public PngChunk GetById1(String id, bool failIfMultiple)
        {
            return GetById1(id, null, failIfMultiple);
        }

        public PngChunk GetById1(String id)
        {
            return GetById1(id, false);
        }

        public List<PngChunk> GetEquivalent(PngChunk c2)
        {
            return ChunkHelper.FilterList(chunks, new ChunkPredicateEquiv(c2));
        }

        public override String ToString()
        {
            return "ChunkList: read: " + chunks.Count;
        }

        /**
         * for debugging
         */
        public String ToStringFull()
        {
            StringBuilder sb = new StringBuilder(ToString());
            sb.Append("\n Read:\n");
            foreach (PngChunk chunk in chunks)
            {
                sb.Append(chunk).Append(" G=" + chunk.ChunkGroup + "\n");
            }
            return sb.ToString();
        }

    }
}
