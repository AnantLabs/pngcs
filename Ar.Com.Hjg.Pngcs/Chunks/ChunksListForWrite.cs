// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace Ar.Com.Hjg.Pngcs.Chunks
{

    using Ar.Com.Hjg.Pngcs;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;

    /// <summary>
    /// Chunks to be written - not including IDHR/ IDAT / END (buy yes PLTE)
    /// http://www.w3.org/TR/PNG/#table53
    /// </summary>
    ///
    public class ChunksListForWrite : ChunksList
    {

        // chunks not yet writen - does not include IHDR, IDAT, END, perhaps yes PLTE
        private List<PngChunk> queuedChunks;
        
        // redundant, just for eficciency
        private HashSet<String> alreadyWrittenKeys ;

        public ChunksListForWrite(ImageInfo info)
            : base(info)
        {
            this.queuedChunks = new List<PngChunk>();
            this.alreadyWrittenKeys = new HashSet<String>();
        }

        /**
         * Same as getById(), but looking in the queued chunks
         */
        public List<PngChunk> GetQueuedById(String id)
        {
            return GetQueuedById(id, null);
        }

        /**
         * Same as getById(), but looking in the queued chunks
         */
        public List<PngChunk> GetQueuedById(String id, String innerid)
        {
            return GetXById(queuedChunks, id, innerid);
        }

        /**
         * Same as getById1(), but looking in the queued chunks
         **/
        public PngChunk GetQueuedById1(String id, String innerid, bool failIfMultiple)
        {
            List<PngChunk> list = GetQueuedById(id, innerid);
            if (list.Count == 0)
                return null;
            if (list.Count > 1 && (failIfMultiple || !list[0].AllowsMultiple()))
                throw new PngjException("unexpected multiple chunks id=" + id);
            return list[list.Count - 1];
        }

        /**
         * Same as getById1(), but looking in the queued chunks
         **/
        public PngChunk GetQueuedById1(String id, bool failIfMultiple)
        {
            return GetQueuedById1(id, null, failIfMultiple);
        }

        /**
         * Same as getById1(), but looking in the queued chunks
         **/
        public PngChunk GetQueuedById1(String id)
        {
            return GetQueuedById1(id, false);
        }

        /**
         * Remove Chunk: only from queued
         * 
         * WARNING: this depends on c.equals() implementation, which is straightforward for SingleChunks. For
         * MultipleChunks, it will normally check for reference equality!
         */
        public bool RemoveChunk(PngChunk c)
        {
            return queuedChunks.Remove(c);
        }

        /**
         * behaviour:
         * 
         * 
         * @param c
         */
        public bool queue(PngChunk c)
        {
            queuedChunks.Add(c);
            return true;
        }

        /**
         * this should be called only for ancillary chunks and PLTE (groups 1 - 3 - 5)
         **/
        private static bool shouldWrite(PngChunk c, int currentGroup)
        {
            if (currentGroup == CHUNK_GROUP_2_PLTE)
                return c.Id.Equals(ChunkHelper.PLTE);
            if (currentGroup % 2 == 0)
                throw new PngjException("?");
            int minChunkGroup, maxChunkGroup;
            if (c.mustGoBeforePLTE())
                minChunkGroup = maxChunkGroup = ChunksList.CHUNK_GROUP_1_AFTERIDHR;
            else if (c.mustGoBeforeIDAT())
            {
                maxChunkGroup = ChunksList.CHUNK_GROUP_3_AFTERPLTE;
                minChunkGroup = c.mustGoAfterPLTE() ? ChunksList.CHUNK_GROUP_3_AFTERPLTE
                        : ChunksList.CHUNK_GROUP_1_AFTERIDHR;
            }
            else
            {
                maxChunkGroup = ChunksList.CHUNK_GROUP_5_AFTERIDAT;
                minChunkGroup = ChunksList.CHUNK_GROUP_1_AFTERIDHR;
            }

            int preferred = maxChunkGroup;
            if (c.Priority)
                preferred = minChunkGroup;
            if (ChunkHelper.IsUnknown(c) && c.ChunkGroup> 0)
                preferred = c.ChunkGroup;
            if (currentGroup == preferred)
                return true;
            if (currentGroup > preferred && currentGroup <= maxChunkGroup)
                return true;
            return false;
        }

        public int writeChunks(Stream os, int currentGroup)
        {
            List<int> written = new List<int>();
            for(int i=0;i<queuedChunks.Count;i++)
            {
                PngChunk c = queuedChunks[i];
                if (!shouldWrite(c, currentGroup))
                    continue;
                if (ChunkHelper.IsCritical(c.Id) && !c.Id.Equals(ChunkHelper.PLTE))
                    throw new PngjOutputException("bad chunk queued: " + c);
                if (alreadyWrittenKeys.Contains(c.Id) && !c.AllowsMultiple())
                    throw new PngjOutputException("duplicated chunk does not allow multiple: " + c);
                c.write(os);
                chunks.Add(c);
                alreadyWrittenKeys.Add(c.Id);
                written.Add(i);
                c.ChunkGroup= currentGroup;
            }
            for (int k = written.Count - 1; k >= 0; k--)
            {
                queuedChunks.RemoveAt(written[k]);
            }
            return written.Count;
        }

        /**
 * warning: this is NOT a copy, do not modify
 */
        internal List<PngChunk> GetQueuedChunks()
        {
            return queuedChunks;
        }
    }
}
