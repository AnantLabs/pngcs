// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 6/1/11 9:13 a.m.    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace Ar.Com.Hjg.Pngcs.Chunks
{

    using Ar.Com.Hjg.Pngcs;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;



    // see http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
    public abstract class PngChunk
    {
        public readonly String Id; // 4 letters
        public readonly bool Crit, Pub, Safe;
        protected internal readonly ImageInfo ImgInfo;


        private bool priority = false; //For writing. Queued chunks with high priority will be written as soon as possible
        public bool Priority { get { return priority; } set { priority = value; } }

        private int chunkGroup = -1; // chunk group where it was read or writen
        public int ChunkGroup { get { return chunkGroup; } set { chunkGroup = value; } }

        private int lenori = -1; // merely informational, for read chunks


        public enum ChunkOrderingConstraint
        {
            NONE,
            BEFORE_PLTE_AND_IDAT,
            AFTER_PLTE_BEFORE_IDAT,
            BEFORE_IDAT, NA
        }

        protected PngChunk(String id_0, ImageInfo imgInfo_1)
        {
            this.Id = id_0;
            this.ImgInfo = imgInfo_1;
            this.Crit = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsCritical(id_0);
            this.Pub = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsPublic(id_0);
            this.Safe = Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.IsSafeToCopy(id_0);
        }

        private static Dictionary<String, Type> factoryMap = initFactory();

        private static Dictionary<String, Type> initFactory()
        {
            Dictionary<String, Type> f = new Dictionary<string, System.Type>();
            f.Add(ChunkHelper.IDAT, typeof(PngChunkIDAT));
            f.Add(ChunkHelper.IHDR, typeof(PngChunkIHDR));
            f.Add(ChunkHelper.PLTE, typeof(PngChunkPLTE));
            f.Add(ChunkHelper.IEND, typeof(PngChunkIEND));
            f.Add(ChunkHelper.tEXt, typeof(PngChunkTEXT));
            f.Add(ChunkHelper.iTXt, typeof(PngChunkITXT));
            f.Add(ChunkHelper.zTXt, typeof(PngChunkZTXT));
            f.Add(ChunkHelper.bKGD, typeof(PngChunkBKGD));
            f.Add(ChunkHelper.gAMA, typeof(PngChunkGAMA));
            f.Add(ChunkHelper.pHYs, typeof(PngChunkPHYS));
            f.Add(ChunkHelper.iCCP, typeof(PngChunkICCP));
            f.Add(ChunkHelper.tIME, typeof(PngChunkTIME));
            f.Add(ChunkHelper.tRNS, typeof(PngChunkTRNS));
            f.Add(ChunkHelper.cHRM, typeof(PngChunkCHRM));
            f.Add(ChunkHelper.sBIT, typeof(PngChunkSBIT));
            f.Add(ChunkHelper.sRGB, typeof(PngChunkSRGB));
            f.Add(ChunkHelper.hIST, typeof(PngChunkHIST));
            f.Add(ChunkHelper.sPLT, typeof(PngChunkSPLT));
            // extended
            f.Add(PngChunkOFFS.ID, typeof(PngChunkOFFS));
            f.Add(PngChunkSTER.ID, typeof(PngChunkSTER));
            return f;
        }

        public static void FactoryRegister(String chunkId, Type type)
        {
            factoryMap.Add(chunkId, type);
        }

        internal static bool isKnown(String id)
        {
            return factoryMap.ContainsKey(id);
        }

        internal bool mustGoBeforePLTE()
        {
            return GetOrderingConstraint() == ChunkOrderingConstraint.BEFORE_PLTE_AND_IDAT;
        }

        internal bool mustGoBeforeIDAT()
        {
            ChunkOrderingConstraint oc = GetOrderingConstraint();
            return oc == ChunkOrderingConstraint.BEFORE_IDAT || oc == ChunkOrderingConstraint.BEFORE_PLTE_AND_IDAT || oc == ChunkOrderingConstraint.AFTER_PLTE_BEFORE_IDAT;
        }

        internal bool mustGoAfterPLTE()
        {
            return GetOrderingConstraint() == ChunkOrderingConstraint.AFTER_PLTE_BEFORE_IDAT;
        }

  

        internal static PngChunk Factory(ChunkRaw chunk, ImageInfo info)
        {
            PngChunk c = FactoryFromId(Ar.Com.Hjg.Pngcs.Chunks.ChunkHelper.ToString(chunk.IdBytes), info);
            c.lenori = chunk.Length;
            c.ParseFromRaw(chunk);
            return c;
        }

        /**
 * Creates one new blank chunk of the corresponding type, according to factoryMap (PngChunkUNKNOWN if not known)
 */
        internal static PngChunk FactoryFromId(String cid, ImageInfo info)
        {
            PngChunk chunk = null;
            if (factoryMap == null) initFactory();
            if (isKnown(cid))
            {
                Type t = factoryMap[cid];
                if (t == null) Console.Error.WriteLine("What?? " + cid);
                System.Reflection.ConstructorInfo cons = t.GetConstructor(new Type[] { typeof(ImageInfo) });
                object o = cons.Invoke(new object[] { info });
                chunk = (PngChunk)o;
            }
            if (chunk == null)
                chunk = new PngChunkUNKNOWN(cid, info);

            return chunk;
        }

        internal ChunkRaw createEmptyChunk(int len, bool alloc)
        {
            ChunkRaw c = new ChunkRaw(len, ChunkHelper.ToBytes(Id), alloc);
            return c;
        }


        /* @SuppressWarnings("unchecked")*/
        internal static T CloneChunk<T>(T chunk, ImageInfo info) where T : PngChunk
        {
            PngChunk cn = FactoryFromId(chunk.Id, info);
            if ((Object)cn.GetType() != (Object)chunk.GetType())
                throw new PngjException("bad class cloning chunk: " + cn.GetType() + " "
                        + chunk.GetType());
            cn.CloneDataFromRead(chunk);
            return (T)cn;
        }

        internal void write(Stream os)
        {
            ChunkRaw c = CreateRawChunk();
            if (c == null)
                throw new PngjException("null chunk ! creation failed for " + this);
            c.WriteChunk(os);
        }

        public override String ToString()
        {
            return "chunk id= " + Id + " (" + lenori + ") c=" + GetType().Name;
        }

        /// <summary>
        /// 
        /// </summary>
        public abstract ChunkRaw CreateRawChunk();

        public abstract void ParseFromRaw(ChunkRaw c);

        // override to make deep copy from read data to write
        public abstract void CloneDataFromRead(PngChunk other);

        public abstract bool AllowsMultiple(); // this is implemented in PngChunkMultiple/PngChunSingle

        public abstract ChunkOrderingConstraint GetOrderingConstraint();


    }
}
